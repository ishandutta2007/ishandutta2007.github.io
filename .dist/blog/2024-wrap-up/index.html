<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          What I learned in 2024 | Zap's website
        
      
    </title><link href=/styles/fonts.css rel=stylesheet><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Zap</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">What I learned in 2024</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Sun, Jan 12 2025</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="1355 words"> 6 minutes read </abbr></div></div></header><article class=content__body><p>Usually, people write this kind of post somewhere at the end of the year. But I had another deadline and haven’t collected my thoughts yet, so this post came quite late. Nonetheless, I really wanted to look back at 2024 because it’s been quite an interesting year for me.</p><span id=continue-reading></span><p>2023-2024 is my first academic year in college, and to me college is more like for applying what I learned in an academic environment than for learning. I’m not built for learning a standardized curriculum and prefer learning things as I need them, on my own. However, there is a good thing that came out of it.<h1 id=implementing-data-structures>Implementing data structures</h1><p>In my third semester, I got enrolled in a Data structures and algorithm course. I was taught by some of the best, but the course itself is kinda superficial. In the course, you don’t learn to solve any real problem, just memorizing a bunch of data structures, algorithms, their properties, and whatnot. You don’t even have to implement most of what being taught, the most complex data structure you have to implement is the AVL tree.<p>But this course made me do something that I wouldn’t do on my own: Implementing data structures. I even took a special assignment of implementing a red-black tree, which was fun and nightmarish at the same time. I wasn’t a data structure person and prefer implementing algorithms instead. For me, algorithms were just more unique and interesting, and I thought that you can just use data structures from (standard) libraries.<p>But I realized that just like algorithms, data structures can also be carefully tuned to fit your particular data and use case. Implementing them is also good for practicing memory operations. This year, I implemented these data structures:<ul><li>Stack and queue using <a href=/blog/queue/>arrays</a> and linked lists<li>Associative containers using <a href=/blog/string-matching/>hash tables</a> and BSTs<li>Priority queue using BSTs and binary heaps<li>Spatial acceleration structures using Quadtrees and KD-Trees</ul><p>Overall, I think that implementing these data structures are crucial, as now I have better understanding and control of how my data is laid out in memory. Also, if I ever need a data structure, I can just straight up implementing them because I’m more confident that I can correctly implement it.<h1 id=starting-this-website>Starting this website</h1><p>I think the most influential decision I made in 2024 is to start this website. With that, I’ve been trying to better articulate my thoughts and ideas, and writing them down coherently. I don’t know if I ever feel satisfied with my writings, but I’m proud that I manage to write <em>something</em> every month or so last year.<p>Besides writing, I also learned how to use a static site generator to build content-based web applications. After a year, it’s safe to say that Zola is pretty awesome. There are some features that I wanted to use, such as tags, pagination, search, etc. But I think it’s better to wait for the content of this website to grow before doing anything.<p>If there’s anything on this website that I’m proud of, it’s the CSS design. It was the first time that I design a multipage website, and I’m pretty happy that it came together quite nicely. I also learned how to incorporate SVG design assets to make the website more organic and playful. There are still things that I’d like to add to the design, such as custom fonts and a dark theme.<h1 id=resource-lifetime-and-ownership>Resource lifetime and ownership</h1><p>This seems like a Rust thing, and indeed, I learned it using Rust as it forces you to think about it. But in reality, the concept of lifetime and ownership extends to other programming languages, just that it wasn’t strictly enforced. Learning this made me code better in other languages where resource (mostly memory) management is manual.<p>In C++, I was able to use <code>std::unique_ptr</code> in more dynamic and powerful ways, such as composing them in <code>struct</code>s or <code>class</code>es, knowing when to move, copy, or reference them. It has gotten to the point where it’s now my default way of doing heap allocation. Similarly, I no longer blindly copy everything when it doesn’t affect the time complexity. The benefit of learning resource lifetime and ownership is not safety, you can achieve safety in other ways. The main benefit is performance, as garbage collection and reference counting is not required, and you avoid lots of unnecessary resource allocation and deallocation.<p>For C, single-resource lifetime isn’t enough to make me feel confident with resource management, but it was a step in the right direction. I work better with pointers, reduced <code>malloc</code>, <code>memcpy</code> and <code>free</code>, but it wasn’t enough. I have to start learning how to group objects with the same lifetime into <a href=/blog/arena>arenas</a> and dynamic arrays, start thinking not in terms of individual lifetimes, but in systems and groups of objects. This was my first step in learning data-oriented design and resulted in much more robust and performant code.<h1 id=functional-programming>Functional programming</h1><p>It’s pretty clear that Rust had a massive influence on me in 2024, and I think the biggest of which is that it introduced me to functional programming. I’ve known functional programming since around 2020, but my imperative brain couldn’t really comprehend it. Rust slowly and subtly helped me approach some functional programming concepts, such as:<ul><li>Thinking in types and functions instead of classes<li>Algebraic data types, especially <a href=/blog/polymorphism>tagged union</a><li>Pattern matching and type decomposition<li>Expression-based programming<li>Monadic error handling<li>Functional sequence manipulation</ul><p>Being an imperative programmer, I’m not as efficient with these concepts compared to their imperative alternatives, but I’m slowly getting the hang of it. I learned some concepts faster, for example functional sequence manipulation, because I used similar techniques (Python’s <a href=//docs.python.org/3/tutorial/datastructures.html#list-comprehensions>comprehension</a> and C# <a href=//learn.microsoft.com/en-us/dotnet/csharp/linq/>LINQ</a>).<p>Rust is great because I can turn back to imperative programming when it’s more appropriate, but it also made me rely too much on my old imperative style. I only fully embraced functional programming when I have to configure my new NixOS system. Nix is a great application of functional programming and gave a huge motivation to learn more about it.<h1 id=heading-to-2025>Heading to 2025</h1><p>So those are what I learned last year. With that being said, what am I going to learn in 2025? I don’t stick to plans very well, so I’m just going to list out what I wanted to learn instead. Firstly, Rust has been my source of influence in 2024, so this year I wanted something different. As mentioned above, I dipped my toe into the world of data-oriented design, so I wanted a language that facilitate it. One such language is Zig, and I’ve already been using it for as a build system for C and C++ last year. There’s one of my project idea that could benefit from Zig features, so I’m looking forward to start developing it and learn Zig.<p>Metaprogramming is a topic that I’ve always been interested with. My approach to metaprogramming has been one of the following:<ul><li>C++ <code>template</code>/<code>constexpr</code><li>Scripts that run as part of the build process to dynamically generate code</ul><p>The latter is especially powerful and capable of doing almost everything that I ever wanted to do with metaprogramming, to the point that I just use it with C instead of C++. But this year, I want to learn other approaches to metaprogramming, such as:<ul><li>Zig compile time code execution and reflection<li>LISP quoting and quasiquoting<li>Rust AST metaprogramming with macros</ul><p>It’s pretty obvious how I will learn these approaches. I haven’t decided which flavor of LISP to use, but then again, I don’t know if I’ll learn this at all. I doubt that any of these approaches are as efficient and flexible as the code generating scripts approach, but I still want to try them. There are more things that I want to try, such as functional languages like Haskell or OCaml, but I think that for the time being, I should focus on data-oriented design and metaprogramming.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Zap (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>