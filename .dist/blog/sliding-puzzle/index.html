<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          Writing a 15-puzzle solver | Ishan's website
        
      
    </title><link href=/styles/fonts.css rel=stylesheet><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Ishan</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">Writing a 15-puzzle solver</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Sat, Mar 01 2025</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="2880 words"> 12 minutes read </abbr></div></div></header><article class=content__body><p>In computer science, the problems that captivate me the most are the ones that are just a bit more difficult to optimally solve with current hardware limitations. They often require careful engineering and strategic trade-off considerations to come up with suboptimal, but good-enough solutions.<p>One such problem is finding the shortest solution to the <a href=//en.wikipedia.org/wiki/15_puzzle>15-puzzle</a>. With the state space size of 10^13, average branching factor of 2, and longest solution length of 80, it’s impossible to find the shortest solution using conventional search algorithms. However, I implemented an algorithm that can optimally solve a vast majority of random instances pretty quickly.</p><span id=continue-reading></span><h1 id=background>Background</h1><p>I used to solve sliding tile puzzles as a kid, and soon figured out that it’s actually quite easy to solve them by breaking them down into smaller subtasks. Last year, during one of my introductory courses in college, I was introduced to the problem of finding the shortest solution to sliding puzzles, and how it can be formulated as a path-finding problem. I was interested, but never got to do it because back at the time, the thought of implementing custom data structures (priority queues and hash maps) is too much for me.<p>A year later, I was confident enough in my ability to <a href=/blog/2024-wrap-up#implementing-data-structures>implement data structures</a>, so I finally embarked on a journey to solve this puzzle. It turns out that the challenge was more than just a priority queue, so this post documents the process of designing and implementing the solver. Before reading on, I recommend trying out the final result hosted as a website: <a href=https://ishandutta2007.github.io/sliding-puzzle>https://ishandutta2007.github.io/sliding-puzzle</a>.<h1 id=tech-stack>Tech stack</h1><p>Now you might be thinking, what’s so hard about a priority queue, they’re already implemented in most standard libraries. For starter, I was planning on distributing the solver as a website, so I’m left with 2 options: JavaScript, or WebAssembly. Obviously, the solver is going to be computationally expensive, so implementing it in JavaScript is out of the window. And I don’t just want to use WebAssembly, I want to use <a href=/blog/wasm/>freestanding WebAssembly</a>.<p>Using freestanding WebAssembly means that I don’t have access to any heap memory allocator. While I can <a href=/blog/arena/>implement my own</a>, I think that it’s better not to use one, or deeply integrate it into the data structures to efficiently utilize memory. Thinking back, it’s still possible to use some existing data structures implementation. But writing my own actually led me to think deeper about the problem, and prompted me to came up with a way to optimize the time complexity of the solver.<p>So I need a language for compiling to freestanding WebAssembly. My usual choice would be to use C, but as <a href=/blog/2024-wrap-up#heading-to-2025>stated before</a>, I wanted an excuse to write Zig, so decided to use that instead. I’m planning on replacing C as my “language for WebAssembly”, and Zig is a good contender. I wanted to talk about my thoughts on Zig after this project, but it’s out of the scope of this article.<p>To visualize the solver, I needed a web UI, so reached for my favorite web framework: <a href=http://vanilla-js.com/>vanilla-js</a>. It’s 2025, and type-safety is preached everywhere, so I annotated my JS code with <a href=//jsdoc.app/>jsdoc</a> and use <code>tsc</code> for type-checking without a build step. I’ll talk about the web UI later, but for now, let’s focus on the search algorithm.<h1 id=a-search-algorithm>A* search algorithm</h1><p>Because the problem can be formulated as a path-finding problem, the most obvious tool for the job is a path-finding algorithm. For the 8-puzzle variant, the state space is small enough, so a simple Breadth-first search is sufficient. For 15-puzzle, however, you can’t afford to search the entire search space, so we need a way to guide the search process towards the goal. Enters A*, which uses a goal-directed heuristic only find the shortest path from the initial state to the goal state, as opposed to BFS and Dijkstra’s algorithm which finds the shortest-path spanning tree to all possible goal.<p>To implement A*, two data structures are required: the open set, and the closed set. The open set stores nodes yet to be explored, along with the estimated cost of such nodes. The closed set stores a spanning tree from the initial state to all explored nodes, so when the goal is reached, the spanning tree is traversed backward to reconstruct the path. The algorithm itself is quite simple: Each iteration, remove the item with the lowest cost from the open set and add its neighbors to the closed set if a better path is found. So the hard part of implementing the A* search algorithm is the representation of the open and closed set.<h2 id=attempt-1-naive-representation>Attempt 1: Naive representation</h2><p>The most efficient way to implement the set interface is to use hash tables. So to save memory and for better lookup speed, we can use the same hash table for both the open and closed set. We can use a boolean to indicate whether the entry points to the open or closed set.<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const </span><span>HTEntry </span><span style=color:#c678dd>= struct </span><span>{
</span><span>  </span><span style=color:#e06c75>in_open</span><span>: </span><span style=color:#c678dd>bool</span><span>,
</span><span>  </span><span style=color:#e06c75>index</span><span>: </span><span style=color:#c678dd>u32</span><span>,
</span><span>};
</span></code></pre><p>Note that I used a <code>u32</code> instead of a pointer because both the open set and closed set can use array-based data structures. Depending on the <code>is_open</code> field, we can index the correct array to retrieve the node. Note that a boolean only represent 1 bit of information, but because the alignment is 4 bytes, this representation actually costs us 31-bit per entry. However, for better performance, the hash table isn’t dense, so we’re actually wasting <code>31 + 64 * (1 / LF - 1)</code> bits per entry, where <code>LF</code> is the load-factor of the hash table. I usually use a very low load factor like 50%, so we’re wasting <code>95</code> bits per entries, <code>63</code> bits more than what is actually needed.<p>That’s only for the hash table. Since I’m not using a heap memory allocator, we need to figure out the upper bound of how many nodes are stored in either set. The worse case is that all entries in the hash table points to only one of the two set, so the capacity of either set must be the same as the hash table. This means that we’re also wasting precious memories for the sets. This can be further illustrated with the figure below.<figure><img alt="separate sets visualization" src=./separate-sets.svg><figcaption>Illustration of wasted space when using two separate arrays</figcaption></figure><p>This representation is pretty straightforward, but the memory overhead is quite concerning, especially when we are wasting <code>63</code> bits just to store a boolean. I was wondering if there is a way to eliminate all aforementioned memory overhead, and the answer is yes.<h2 id=attempt-2-heapsort-inspired-representation>Attempt 2: Heapsort inspired representation</h2><p>To avoid the wasteful memory usage of that boolean, there are two options:<ol><li>Store the boolean in a separate bitset<li>Use something else to indicate which sets the node belongs to</ol><p>The second approach is clearly superior, as it doesn’t have any memory overhead. But in order to use it, we need to rearrange our data in a way that querying for which set a node is in more efficiently. The method that I came up with is inspired by how <a href=//en.wikipedia.org/wiki/Heapsort>Heapsort</a> was optimized to perform without additional memory.<p>To perform Heapsort in-place, the array is divided into a prefix and a suffix with different arrangement strategy. During the heapify phase, the prefix is unsorted, and the suffix is heap-ordered. During the sorting phase, the prefix is heap-ordered and the suffix is sorted. This dual-arrangement allows the algorithm to efficiently utilize memory and only the original array is required, as opposed to requiring two arrays with their own arrangements.<p>With this in mind, for the new layout, I only use a single array with the same size as the capacity of the hash table. The array is then divided into three parts: The prefix, infix, and suffix. The prefix is used to store the open-set, and is heap-ordered to accelerate finding the node with the lowest cost. The suffix is used to store the closed-set, and has no meaningful ordering other than items are inserted backward. The infix is just an auxiliary space, storing the available memory the prefix and suffix can use. The layout can be visualized more clearly with the figure below:<figure><img alt="heapsort-inspired layout visualization" src=./heapsort-inspired.svg><figcaption>Visualization of the heapsort-inspired layout</figcaption></figure><p>Because only a single array is used, the amount of wasted memory is drastically reduced. We can use two indices (or pointers) to mark the end of the prefix and the start of the suffix. When the indices cross each-other, we ran out of memory. The boolean problem is also solved, to tell which set a node belongs to, we can just compare its index to the marking indices. Now, with the load factor of 50%, the hash table only costs 64-bit per entry, and the memory usage of the two sets is reduced by half. It doesn’t matter how much memory each set use, the total amount of memory stays the same and is automatically allocated to either sets.<p>This is a very memory-efficient implementation of A*, and I think that I’ll use it for future generic, memory-constrained A* implementations. It’s also surprisingly efficient, but maybe that’s just the added benefit of using little memory and avoid heap allocation (and fragmentation). I used this implementation for a while until I can make enough assumptions about the problem to optimize it even further.<h2 id=attempt-3-uniform-cost-graph-optimization>Attempt 3: Uniform-cost graph optimization</h2><p>For the problem of finding the shortest solution for the 15-puzzle, we are trying to minimize the number of actions, so the cost of each action is always 1. This is why we can use BFS for the smaller 8-puzzle variant. Although A* drastically reduces the number of expanded nodes, the overhead of A* isn’t unnoticeable. With the previous priority queue implementation, each iteration of A* has the time complexity of <code>O(log n)</code>, along with the overhead of moving nodes around in the array to maintain the heap order, BFS is looking pretty lucrative not gonna lie.<p>So how do we combine the efficiency of BFS for uniform-cost graph and the goal-directed node reduction of A*? I found out a strategy, but it requires a specific property of the heuristic function: If there is an action from node <code>N</code> to node <code>P</code> then <code>|h(N) - h(P)| = 1</code>. This means that moving from node <code>N</code> to node <code>P</code> only increases or decreases the heuristic by 1. Therefore, the estimated cost only either stays the same or increase by 2.<p>This assumption allows us to use a more specialized data structure: <a href=//en.wikipedia.org/wiki/Bucket_queue>bucket queue</a>. If heapsort is a selection sort optimized to <code>O(n log n)</code> using a binary heap as the data structure for the priority queue; then <a href=//en.wikipedia.org/wiki/Pigeonhole_sort>pigeonhole sort</a> is a selection sort optimized to <code>O(n)</code> using a bucket queue as the data structure for the priority queue. Bucket queue cheats the <code>O(log n)</code> lower bound by using the assumption that the range of priorities fits inside a predetermined number of buckets.<p>We established that when the minimum estimated cost is <code>n</code>, the estimated cost of its children is either <code>n</code> or <code>n + 2</code>. So we can use a bucket queue with 2 buckets to store them. Once the minimum estimated cost became <code>n + 2</code>, we need a bucket to store the node with estimated cost of <code>n + 4</code>, but then the bucket of priority <code>n</code> is emptied and can be used for priority <code>n + 4</code>. We can use the previous strategy to store 2 buckets in a single array, but it complicates the process of reusing buckets, so I decided to just use an array for each bucket.<p>This implementation is not only theoretically more efficient, but the code is surprisingly a bit simpler as well. It’s only slightly more than regular BFS, because if you think about it, BFS is Dijkstra’s algorithm using a bucket queue of size 2 as the priority queue. It’s time to address the elephant in the room: What kind of heuristic has that specific property? Both the Manhattan distance heuristic and the generalized <a href=//arxiv.org/abs/1107.0050>Additive Pattern Database heuristic</a> satisfies the property and can be used with bucket queue.<h1 id=hybrid-a-search>Hybrid A* search</h1><p>So after all these memory and speed optimizations, how fast can the algorithm solve random instances of the puzzle? The answer is that it can’t, because it will eventually run out of memory. No matter how much we try and optimize the search algorithm? We can’t ignore the fact that 10^13 states requires more than 9.5 TB to store. The pattern database heuristic can reduce the number of expanded states thousands of times, but even that is still not enough.<p>One popular non memory-bounded variant of A* is <a href=//www.cse.sc.edu/~mgv/csce580f09/gradPres/korf_IDAStar_1985.pdf>iterative deepening A*</a>. The benefit of IDA* is that it’s a depth-first algorithm, so it uses memory proportional to the length of the solution, which is only 80. In practice, less memory often leads to better cache locality, hence improved performance. So IDA* oftentimes outperforms A* even in cases where there’s enough memory for A*. IDA* is also much simpler to implement than A*, with the only necessary data structure being just a stack.<p>So, is that it, is all my effort optimizing A* for nothing? In fact, I’m quite glad that I started with A* instead of IDA*. Otherwise, I’d be happy with the performance of IDA* and stopped investigating further. Luckily, my effort was not in vain. In a recent (2019) <a href=//www.ijcai.org/Proceedings/2019/0168.pdf>paper</a>, a hybrid search algorithm that combines A* and IDA* was proposed and became SOTA for the 24-puzzle. The gist is that while IDA* typically has lower overhead, it also doesn’t consider duplicate states, which can accumulate quite a lot deeper into the search. A*, being a dynamic programming based algorithm, is much more effective than using a generic transposition table.<p>Because I tried my best to reduce the overhead of A* as much as possible, it came as no surprise that the hybrid search algorithm is on average 6.5 times faster (on my machine) than the plain IDA* search. All while being able to optimally solve all instances of the puzzle, unlike the plain A* version. Currently, the native version of the algorithm takes on average 40 milliseconds to solve a puzzle.<h1 id=creating-the-web-ui>Creating the web UI</h1><p>After implementing the algorithm and having no more clear path on how to optimize it, I decided to finally start building the web UI to showcase and visualize the solver. Because I tried really hard not to use the standard library, compiling to WebAssembly was a pretty straightforward process. I try not to put too much effort into the UI because I want to be done with this project and move on to something else. And I thought that it turned out pretty okay. The UI was a bit more bland and unintuitive than I’d like to, and the JavaScript code was all over the place. But I think that it’s good enough and capable of doing what I want it to do.<p>The biggest challenge is to load a 61 MB pattern database into the website. I tried to host it as a release, and <code>fetch</code> it in the client, but <a href=//developer.mozilla.org/en-US/docs/Web/HTTP/CORS>CORS</a> decided that it’s not secure. So without any other options, I gzipped the database into an 18 MB file, commit it with the rest of the codebase and host it on GitHub pages. I know that committing large binary blobs is an unforgivable crime, but there’s nothing else that I can do.<p>Downloading an 18 MB file every time the page loads is also painfully slow. So I implemented a manual caching system. This is my first time trying out the <a href=//javascript.info/indexeddb>IndexedDB</a> API and it was excruciating. The W3C people really try their best to make doing simple tasks as complicated as possible. There’s also <a href=//web.dev/articles/origin-private-file-system>OPFS</a>, but somehow I only knew about it right after I’m done with this project. After dealing with all the nonsense that is the Web API, I finally created a cross-platform demo of by 15-puzzle optimal solver that’s pretty fast and small.<h1 id=conclusion>Conclusion</h1><p>That’s all there is to how I created a solver for the 15-puzzle. If you haven’t already, check it out <a href=//ishandutta2007.github.io/sliding-puzzle>here</a>. This has been a fun journey, and I haven’t even gone in depth into how Zig made it so much more enjoyable (especially for programming the pattern database heuristic). I glossed over many parts of the process, because I think that either those are boring or not unique to my implementation of the solver. But hopefully you can see what went into the design and implementation of a good-enough solution.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Ishan (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>