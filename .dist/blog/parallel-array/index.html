<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          Struct of Arrays (SoA) in TypeScript with metaprogramming | Ishan's website
        
      
    </title><link href=/styles/fonts.css rel=stylesheet><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Ishan</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">Struct of Arrays (SoA) in TypeScript with metaprogramming</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Wed, Sep 17 2025</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="2681 words"> 11 minutes read </abbr></div></div></header><article class=content__body><p>Struct of Arrays (SoA) is the bread and butter and textbook example of <a href=//en.wikipedia.org/wiki/Data-oriented_design>Data-oriented design</a>. It’s mostly popular in <a href=//unity.com/dots>game development</a> due to enhanced performance in many gamedev specific operations. You might also encounter SoAs in analytic and processing heavy databases such as <a href=//pandas.pydata.org/>Pandas</a> or <a href=//duckdb.org/>DuckDB</a>. Of course, in the web development space nobody cares about data layout and optimization. Despite that, I wrote an SoA library in TypeScript, not for the performance gain, but for trying out TypeScript’s type-level metaprogramming.</p><span id=continue-reading></span><h1 id=why-do-we-need-soa>Why do we need SoA</h1><p>I won’t go too in-depth about the difference between Struct of Arrays (SoA) and Array of Structs (AoS). The gist of it is to store each struct field in separate arrays, which has the following benefits:<ul><li>No padding between array items<li>Easier parallelism thanks to homogenous data<li>Improve cache usage when only some fields are needed for a computation</ul><p>In JavaScript, we get even more benefits thanks to typed arrays<ul><li>More compact and stored contiguously, reducing memory consumption<li>Allows for smaller types than 64-bit floating-point numbers</ul><p>Here’s an example of the difference between AoS and SoA in TypeScript. This is the AoS approach, where we use a single array to store all fields.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monster </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#e06c75>x</span><span style=color:#c678dd>: </span><span>number
</span><span>  </span><span style=color:#e06c75>y</span><span style=color:#c678dd>: </span><span>number
</span><span>
</span><span>  </span><span style=color:#e06c75>hp</span><span style=color:#c678dd>: </span><span>number
</span><span>}
</span><span>
</span><span style=color:#c678dd>const </span><span style=color:#e06c75>monsters </span><span style=color:#c678dd>= new </span><span>Array&LTMonster>()
</span><span>
</span><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#61afef>push</span><span>({
</span><span>  x: </span><span style=color:#e5c07b>0</span><span>,
</span><span>  y: </span><span style=color:#e5c07b>0</span><span>,
</span><span>  hp: </span><span style=color:#e5c07b>100</span><span>,
</span><span>})
</span></code></pre><p>This is clear and intuitive, but let’s take a look at an operation: counting alive monsters<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>countAlive</span><span>(</span><span style=color:#e06c75>monsters</span><span style=color:#c678dd>: readonly </span><span>Monster[])</span><span style=color:#c678dd>: </span><span>number {
</span><span>  </span><span style=color:#c678dd>let </span><span style=color:#e06c75>count </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0
</span><span>  </span><span style=color:#c678dd>for </span><span>(</span><span style=color:#c678dd>const </span><span>{ </span><span style=color:#e06c75>hp </span><span>} </span><span style=color:#c678dd>of </span><span style=color:#e06c75>monsters</span><span>) {
</span><span>    </span><span style=color:#c678dd>if </span><span>(</span><span style=color:#e06c75>hp </span><span style=color:#c678dd>> </span><span style=color:#e5c07b>0</span><span>) </span><span style=color:#e06c75>count </span><span style=color:#c678dd>+= </span><span style=color:#e5c07b>1
</span><span>  }
</span><span>  </span><span style=color:#c678dd>return </span><span style=color:#e06c75>count
</span><span>}
</span></code></pre><p>With the current V8 engine, the runtime has to iterate over the <code>monsters</code> array, follow the pointer to get the actual <code>Monster</code> object, and access the <code>hp</code> property. This pollutes the cache with unnecessary information such as the monsters’ coordinates, while the upcoming <code>hp</code> are not loaded. In contrast with the SoA approach:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#e06c75>x</span><span style=color:#c678dd>: </span><span>Float32Array
</span><span>  </span><span style=color:#e06c75>y</span><span style=color:#c678dd>: </span><span>Float32Array
</span><span>  </span><span style=color:#e06c75>hp</span><span style=color:#c678dd>: </span><span>Uint8Array
</span><span>}
</span><span>
</span><span style=color:#c678dd>const </span><span style=color:#e06c75>monsters</span><span style=color:#c678dd>: </span><span>Monsters </span><span style=color:#c678dd>= </span><span style=color:#5c6370>/* ... */
</span></code></pre><p>The first difference is that the fields are properly typed with the exact numeric type, and it uses way less memory than the AoS approach — 9 bytes per element instead of at least 32 bytes. Also, counting alive monsters is significantly more optimized:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>countAlive</span><span>(</span><span style=color:#e06c75>monsters</span><span style=color:#c678dd>: </span><span>Monsters)</span><span style=color:#c678dd>: </span><span>number {
</span><span>  </span><span style=color:#c678dd>let </span><span style=color:#e06c75>count </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0
</span><span>  </span><span style=color:#c678dd>for </span><span>(</span><span style=color:#c678dd>const </span><span style=color:#e06c75>hp </span><span style=color:#c678dd>of </span><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#e06c75>hp</span><span>) {
</span><span>    </span><span style=color:#c678dd>if </span><span>(</span><span style=color:#e06c75>hp </span><span style=color:#c678dd>> </span><span style=color:#e5c07b>0</span><span>) </span><span style=color:#e06c75>count </span><span style=color:#c678dd>+= </span><span style=color:#e5c07b>1
</span><span>  }
</span><span>  </span><span style=color:#c678dd>return </span><span style=color:#e06c75>count
</span><span>}
</span></code></pre><p>There’s no more pointer chasing, no more property access, no more cache pollution, just a simple, sequential memory access. However like always, there’s a catch. With the AoS approach, adding an element to the monster list is easy:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>addMonster</span><span>(</span><span style=color:#e06c75>monsters</span><span style=color:#c678dd>: </span><span>Monster[], </span><span style=color:#e06c75>monster</span><span style=color:#c678dd>: </span><span>Monster) {
</span><span>  </span><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#61afef>push</span><span>(</span><span style=color:#e06c75>monster</span><span>)
</span><span>}
</span></code></pre><p>For the SoA with typed arrays, to begin with, how do you even push an element to the end of typed arrays? You’ll have to write dynamic array implementation on top of typed array. It’s actually quite simple, as I covered <a href=/blog/queue/>before</a>, but then you need to make sure that you push to all arrays and that they are synchronized:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>addMonster</span><span>(</span><span style=color:#e06c75>monsters</span><span style=color:#c678dd>: </span><span>Monsters, </span><span style=color:#e06c75>monster</span><span style=color:#c678dd>: </span><span>Monster) {
</span><span>  </span><span style=color:#e06c75>monsters</span><span>.x.</span><span style=color:#61afef>push</span><span>(</span><span style=color:#e06c75>monster</span><span>.x)
</span><span>  </span><span style=color:#e06c75>monsters</span><span>.y.</span><span style=color:#61afef>push</span><span>(</span><span style=color:#e06c75>monster</span><span>.y)
</span><span>  </span><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#e06c75>hp</span><span>.</span><span style=color:#61afef>push</span><span>(</span><span style=color:#e06c75>monster</span><span>.</span><span style=color:#e06c75>hp</span><span>)
</span><span>}
</span></code></pre><p>This is one of the reasons why some people want SoAs to be a first-class language feature so that we can use them with better ergonomics. In other words, we want the performance of SoAs while retaining the intuitiveness of AoSs. I wanted to see if this is possible with TypeScript metaprogramming.<h1 id=implementation>Implementation</h1><p>When I design modules, I usually start with imagining how I’m going to use it. In this case, we need to support the following basic operations:<ol><li>Access/modify an array corresponding to a struct field<li>Access/modify an element at a specified index<li>Push an “item” to the end of the array<li>Remove and return the last element of the array</ol><p>Only the first operation is unique to this data structure, so I mostly focused on it. I decided to call it <code>view</code>, as we are “viewing” into the underlying layout of the array. Using the previous example, here’s how I’d like to use this operation:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>const </span><span>{</span><span style=color:#e06c75>x</span><span>, </span><span style=color:#e06c75>y</span><span>, </span><span style=color:#e06c75>hp</span><span>} </span><span style=color:#c678dd>= </span><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#61afef>view</span><span>()
</span></code></pre><p>Note that <code>x</code>, <code>y</code>, and <code>hp</code> must be of the correct type, <code>Float32Array</code>, <code>Float32Array</code>, and <code>Uint8Array</code>, respectively. The <code>Monsters</code> type above is in this type already, so our class needs to behave as follows:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#61afef>view</span><span>() </span><span style=color:#c678dd>=> </span><span style=color:#e06c75>Monsters
</span></code></pre><p>One way to do this is to directly store the object:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Monsters
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>view</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Readonly&LTMonsters> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span></code></pre><p>The view is marked as <code>Readonly</code> not because we can’t write to the data, but because we want to disallow changing the properties themselves (JS/TS immutability is weird, I know):<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#e06c75>monsters</span><span>.</span><span style=color:#61afef>view</span><span>().x </span><span style=color:#c678dd>= new </span><span>Float32Array() </span><span style=color:#5c6370>// should give type error
</span></code></pre><p>However, you’ll soon realize that certain operations require iterating over the properties, so it’s better to store the data as an array instead of an object. And we can reconstruct the objects using another keys array.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>keys </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>[</span><span style=color:#98c379>'x'</span><span style=color:#e5c07b>, </span><span style=color:#98c379>'y'</span><span style=color:#e5c07b>, </span><span style=color:#98c379>'hp'</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>as const
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>[Float32Array, Float32Array, Uint8Array]
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>view</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Readonly&LTMonsters> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{}
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>for </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>result</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]] </span><span style=color:#c678dd>= </span><span style=color:#e06c75>data</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>result
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span></code></pre><p>The TypeScript compiler isn’t happy with this, as we are writing dynamic properties to an object. We can get around this using the <code>Record</code> helper type and type assertion. It’s not more type-safe, but it tells the compiler to shut up.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>view</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Readonly&LTMonsters> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Record&LTstring, ArrayLike&LTNumber>> </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>for </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>result</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]] </span><span style=color:#c678dd>= </span><span style=color:#e06c75>data</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>result </span><span style=color:#c678dd>as </span><span style=color:#e5c07b>Monsters
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>}
</span></code></pre><p>With this representation, accessing/modifying data at an arbitrary index is also similar:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>get</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>index</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Monster {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Record&LTstring, number> </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>for </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>result</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]] </span><span style=color:#c678dd>= </span><span style=color:#e06c75>data</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>][</span><span style=color:#e06c75>index</span><span style=color:#e5c07b>]
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>result </span><span style=color:#c678dd>as </span><span style=color:#e5c07b>Monster
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>get</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>index</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number, </span><span style=color:#e06c75>item</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Monster)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>void {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>for </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>data</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>][</span><span style=color:#e06c75>index</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>= </span><span style=color:#e06c75>item</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>]]
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>}
</span></code></pre><p>Note that this constructs/decomposes an object every operation, so it is likely to be very slow. But it makes working with the array a bit easier; just try to avoid them in tight loops.<h2 id=initialize-push-and-memory-allocation>Initialize, push and memory allocation</h2><p>I’d argue that for an SoA abstraction, size-affecting operations are the most important, as it ensures that the backing arrays are all consistent and synchronized. In <a href=/blog/queue>another article</a>, I demonstrated how to create a dynamic array with the push-to-end operation. Here’s a simplified implementation in JavaScript:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>reallocate</span><span>(</span><span style=color:#e06c75>array</span><span>, </span><span style=color:#e06c75>constructor</span><span>, </span><span style=color:#e06c75>capacity</span><span>) {
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>newArray </span><span style=color:#c678dd>= new </span><span>constructor(</span><span style=color:#e06c75>capacity</span><span>)
</span><span>  </span><span style=color:#e06c75>newArray</span><span>.</span><span style=color:#61afef>set</span><span>(</span><span style=color:#e06c75>array</span><span>)
</span><span>  </span><span style=color:#c678dd>return </span><span style=color:#e06c75>newArray
</span><span>}
</span><span>
</span><span style=color:#c678dd>class </span><span style=color:#e5c07b>Stack {
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Uint32Array
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>len</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>push</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>item</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>if </span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>== </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data.length) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data </span><span style=color:#c678dd>= </span><span style=color:#61afef>reallocate</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data, Uint32Array, </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data.length </span><span style=color:#c678dd><< </span><span style=color:#e5c07b>1)
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data[</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>= </span><span style=color:#e06c75>item
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>+= </span><span style=color:#e5c07b>1
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span></code></pre><p>Ignoring the missing type definitions in the <code>reallocate</code> function, if we were to extrapolate this to SoA, we get the following:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>keys </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>[</span><span style=color:#98c379>"x"</span><span style=color:#e5c07b>, </span><span style=color:#98c379>"y"</span><span style=color:#e5c07b>, </span><span style=color:#98c379>"hp"</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>as const
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>constructors </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>[Float32Array, Float32Array, Uint8Array] </span><span style=color:#c678dd>as const
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>InstanceType<</span><span style=color:#c678dd>typeof </span><span style=color:#e5c07b>this.constructors>
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>len</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number
</span><span style=color:#e5c07b>  </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>push</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>item</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Monster) {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>if </span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>== </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity </span><span style=color:#c678dd><<= </span><span style=color:#e5c07b>1
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>      </span><span style=color:#c678dd>for </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>        </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>= </span><span style=color:#61afef>reallocate</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>], </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>i</span><span style=color:#e5c07b>], </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>      }
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#61afef>set</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len</span><span style=color:#e5c07b>, </span><span style=color:#e06c75>item</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>+= </span><span style=color:#e5c07b>1
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span></code></pre><p>If you noticed, this is our first usage of type-system metaprogramming, the <code>typeof</code> keyword, <code>as const</code> operator, and <code>InstanceType</code> utility type. We’ll dive deeper into it later when we generalize the array to support arbitrary object shapes. But for now it’s used so that we don’t have to define the constructors and types separately.<p>Finally, let’s initialize the array and start pushing items into it. I strictly follow the static factory method over constructor principle, which I might write about in the future.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>private </span><span style=color:#e06c75>keys </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>[</span><span style=color:#98c379>"x"</span><span style=color:#e5c07b>, </span><span style=color:#98c379>"y"</span><span style=color:#e5c07b>, </span><span style=color:#98c379>"hp"</span><span style=color:#e5c07b>] </span><span style=color:#c678dd>as const
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>private </span><span style=color:#e06c75>constructors </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>[Float32Array, Float32Array, Uint8Array] </span><span style=color:#c678dd>as const
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>private constructor</span><span style=color:#e5c07b>(
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>InstanceType<</span><span style=color:#c678dd>typeof </span><span style=color:#e5c07b>this.constructors>,
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>size</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>  ) {}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>get </span><span style=color:#61afef>len</span><span style=color:#e5c07b>() {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.size
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return new </span><span style=color:#e5c07b>SoAMonsters(</span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>.</span><span style=color:#61afef>map</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>x </span><span style=color:#c678dd>=> new </span><span style=color:#e5c07b>x(</span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>)), 0, </span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>init</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>SoAMonsters</span><span style=color:#e5c07b>.</span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>(4)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>}
</span></code></pre><p>This avoids the confusion between initialization with a preallocated capacity and initialization with an existing length (like <code>new Array(length)</code>) among other things. Notice that I also made all properties private, the length read-only, and used <code>size</code> as the internal name.<p>This works, but we can optimize it further. Instead of allocating a typed array for each property, we can just allocate a single, large array buffer. Then, for each property, we create a non-overlapping view onto the allocated array buffer. You can think of it as allocating the typed arrays from an <a href=/blog/arena>arena</a> instead of arbitrarily from the heap.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>allocateArrays</span><span>(</span><span style=color:#e06c75>constructors</span><span>, </span><span style=color:#e06c75>capacity</span><span>) {
</span><span>  </span><span style=color:#c678dd>let </span><span style=color:#e06c75>size </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0
</span><span>  </span><span style=color:#c678dd>for </span><span>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>constructors</span><span>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span>) {
</span><span>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>elemSize </span><span style=color:#c678dd>= </span><span style=color:#e06c75>constructors</span><span>[</span><span style=color:#e06c75>i</span><span>].</span><span style=color:#e06c75>BYTES_PER_ELEMENT
</span><span>    </span><span style=color:#e06c75>size </span><span style=color:#c678dd>= </span><span>(</span><span style=color:#e06c75>size </span><span style=color:#c678dd>+ </span><span style=color:#e06c75>elemSize </span><span style=color:#c678dd>- </span><span style=color:#e5c07b>1</span><span>) </span><span style=color:#c678dd>& -</span><span style=color:#e06c75>elemSize
</span><span>    </span><span style=color:#e06c75>size </span><span style=color:#c678dd>+= </span><span style=color:#e06c75>capacity </span><span style=color:#c678dd>* </span><span style=color:#e06c75>elemSize
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>buffer </span><span style=color:#c678dd>= new </span><span>ArrayBuffer(</span><span style=color:#e06c75>size</span><span>)
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result </span><span style=color:#c678dd>= new </span><span>Array(</span><span style=color:#e06c75>constructors</span><span>.length)
</span><span>  </span><span style=color:#c678dd>let </span><span style=color:#e06c75>offset </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0
</span><span>  </span><span style=color:#c678dd>for </span><span>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>constructors</span><span>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span>) {
</span><span>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>elemSize </span><span style=color:#c678dd>= </span><span style=color:#e06c75>constructors</span><span>[</span><span style=color:#e06c75>i</span><span>].</span><span style=color:#e06c75>BYTES_PER_ELEMENT
</span><span>    </span><span style=color:#e06c75>offset </span><span style=color:#c678dd>= </span><span>(</span><span style=color:#e06c75>offset </span><span style=color:#c678dd>+ </span><span style=color:#e06c75>elemSize </span><span style=color:#c678dd>- </span><span style=color:#e5c07b>1</span><span>) </span><span style=color:#c678dd>& -</span><span style=color:#e06c75>elemSize
</span><span>    </span><span style=color:#e06c75>result</span><span>[</span><span style=color:#e06c75>i</span><span>] </span><span style=color:#c678dd>= new </span><span>constructors[i](</span><span style=color:#e06c75>buffer</span><span>, </span><span style=color:#e06c75>offset</span><span>, </span><span style=color:#e06c75>capacity</span><span>)
</span><span>    </span><span style=color:#e06c75>offset </span><span style=color:#c678dd>+= </span><span style=color:#e06c75>capacity </span><span style=color:#c678dd>* </span><span style=color:#e06c75>elemSize
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#c678dd>return </span><span style=color:#e06c75>result
</span><span>}
</span></code></pre><p>Notice that we need to align the buffer, just like with the arena allocator. Then we can update the initialization and reallocation code to use the new allocation strategy.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>reallocate</span><span>(</span><span style=color:#e06c75>arrays</span><span>, </span><span style=color:#e06c75>constructors</span><span>, </span><span style=color:#e06c75>capacity</span><span>) {
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>data </span><span style=color:#c678dd>= </span><span style=color:#61afef>allocateArrays</span><span>(</span><span style=color:#e06c75>constructors</span><span>, </span><span style=color:#e06c75>capacity</span><span>)
</span><span>  </span><span style=color:#c678dd>for </span><span>(</span><span style=color:#c678dd>let </span><span style=color:#e06c75>i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>; </span><span style=color:#e06c75>i </span><span style=color:#c678dd>< </span><span style=color:#e06c75>data</span><span>.length; </span><span style=color:#c678dd>++</span><span style=color:#e06c75>i</span><span>) {
</span><span>    </span><span style=color:#e06c75>data</span><span>[</span><span style=color:#e06c75>i</span><span>].</span><span style=color:#61afef>set</span><span>(</span><span style=color:#e06c75>arrays</span><span>[</span><span style=color:#e06c75>i</span><span>])
</span><span>  }
</span><span>  </span><span style=color:#c678dd>return </span><span style=color:#e06c75>data
</span><span>}
</span><span>
</span><span style=color:#c678dd>class </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return new </span><span style=color:#e5c07b>SoAMonsters(</span><span style=color:#61afef>allocateArrays</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>, </span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>), 0, </span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>init</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>SoAMonsters {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>SoAMonsters</span><span style=color:#e5c07b>.</span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>(4)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>push</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>item</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Monster)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>void {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>if </span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>== </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>) {
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity </span><span style=color:#c678dd><<= </span><span style=color:#e5c07b>1
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data </span><span style=color:#c678dd>= </span><span style=color:#61afef>reallocate</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.data, </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>, </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>    }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#61afef>set</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len</span><span style=color:#e5c07b>, </span><span style=color:#e06c75>item</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>this</span><span style=color:#e5c07b>.</span><span style=color:#e06c75>len </span><span style=color:#c678dd>+= </span><span style=color:#e5c07b>1
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>}
</span></code></pre><p>That’s basically it. Implementing “pop”, or removing and returning the last item, is left as an exercise for the reader.<h1 id=generalize-to-arbitrarily-shape>Generalize to arbitrarily shape</h1><p>Now let’s get to the good part, using type-level metaprogramming to fill in the missing type annotations and generalize the data structure. We can start with defining the layout of the monster object.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>MonsterLayout </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#e06c75>x</span><span style=color:#c678dd>: </span><span style=color:#98c379>'f32'
</span><span>  </span><span style=color:#e06c75>y</span><span style=color:#c678dd>: </span><span style=color:#98c379>'f32'
</span><span>  </span><span style=color:#e06c75>hp</span><span style=color:#c678dd>: </span><span style=color:#98c379>'u8'
</span><span>}
</span></code></pre><p>Now we need to think of a constraint for the layout. Here’s what I came up with:<ol><li>It must be an object type<li>The key can be any arbitrary string<li>The value must be one of the values corresponding to the available typed array</ol><p>To address the first two constraints, we can use the <code>Record</code> like we used above, and for the final constraint, we can use a union. But since the values are related to the available typed array, let’s make a mapping and automatically generate types.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>const </span><span style=color:#e06c75>arrayTypes </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#98c379>'i8'</span><span>: </span><span style=color:#e5c07b>Int8Array</span><span>,
</span><span>  </span><span style=color:#98c379>'u8'</span><span>: </span><span style=color:#e5c07b>Uint8Array</span><span>,
</span><span>  </span><span style=color:#98c379>'i16'</span><span>: </span><span style=color:#e5c07b>Int16Array</span><span>,
</span><span>  </span><span style=color:#98c379>'u16'</span><span>: </span><span style=color:#e5c07b>Uint16Array</span><span>,
</span><span>  </span><span style=color:#98c379>'i32'</span><span>: </span><span style=color:#e5c07b>Int32Array</span><span>,
</span><span>  </span><span style=color:#98c379>'u32'</span><span>: </span><span style=color:#e5c07b>Uint32Array</span><span>,
</span><span>  </span><span style=color:#98c379>'f32'</span><span>: </span><span style=color:#e5c07b>Float32Array</span><span>,
</span><span>  </span><span style=color:#98c379>'f64'</span><span>: </span><span style=color:#e5c07b>Float64Array</span><span>,
</span><span>} </span><span style=color:#c678dd>as const
</span><span>
</span><span style=color:#c678dd>type </span><span>Constraint </span><span style=color:#c678dd>= </span><span>Record&LTstring, </span><span style=color:#c678dd>keyof typeof </span><span>arrayTypes>
</span></code></pre><p>Notice that we used a value object, which is not erased during TypeScript transpilation. This is because we might use it later for looking up the typed array constructors. Taking the <code>typeof</code> operator gives us a mapped type from a string union to typed array constructors. Taking the <code>keyof</code> operator gives us the union itself, which evaluates to<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#98c379>'i8' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'u8' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'i16' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'u16' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'i32' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'u32' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'f32' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'f64'
</span></code></pre><p>Using this as the record value restricts the layout to these values. And we can ensure that we can use these values to index the <code>arrayTypes</code> object. We can also get the constructors and a union of typed arrays similarly.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Constructors </span><span style=color:#c678dd>= </span><span>(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[</span><span style=color:#c678dd>keyof typeof </span><span>arrayTypes]
</span><span style=color:#c678dd>type </span><span>ArrayTypes </span><span style=color:#c678dd>= </span><span>InstanceType&LTConstructors>
</span></code></pre><p>If <code>keyof T</code> returns the key of a mapped type, then <code>T[keyof T]</code> returns the values. This is pretty straightforward and reflects property access at run time. Notice that the type of, for example, <code>Uint32Array</code> is <code>Uint32ArrayConstructor</code>. this is because the <code>arrayTypes</code> object operates in run time, so we are dealing with the actual value <code>Uint32Array</code> which is a constructor. To get back the class, we can use the utility type <code>InstanceType</code>.<p>This gives us the types needed to annotate the functions above, such as<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>function </span><span style=color:#61afef>allocateArrays</span><span>(
</span><span>  </span><span style=color:#e06c75>constructors</span><span style=color:#c678dd>: </span><span>ArrayLike&LTConstructors>,
</span><span>  </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span>number,
</span><span>)</span><span style=color:#c678dd>: </span><span>ArrayTypes[]
</span><span>
</span><span>
</span><span style=color:#c678dd>function </span><span style=color:#61afef>reallocate</span><span>(
</span><span>  </span><span style=color:#e06c75>old</span><span style=color:#c678dd>: </span><span>ArrayLike&LTArrayTypes>,
</span><span>  </span><span style=color:#e06c75>constructors</span><span style=color:#c678dd>: </span><span>ArrayLike&LTConstructors>,
</span><span>  </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span>number,
</span><span>)</span><span style=color:#c678dd>: </span><span>ArrayTypes[]
</span></code></pre><p>With the constraint defined, we can start writing the generic class:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>ParallelArray&LTT </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint> {
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>private constructor</span><span style=color:#e5c07b>(
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private readonly </span><span style=color:#e06c75>constructors</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Constructors[],
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private readonly </span><span style=color:#e06c75>keys</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>keyof </span><span style=color:#e5c07b>T)[],
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>data</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ArrayTypes[],
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>size</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>private </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>  ) {}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#e06c75>init</span><span style=color:#c678dd><</span><span style=color:#e06c75>T1 extends </span><span style=color:#61afef>Constraint</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>ParallelArray</span><span style=color:#e5c07b>.</span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1>(4)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1 </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint>(
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number
</span><span style=color:#e5c07b>  )</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#5c6370>// not implemented
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span><span>
</span><span style=color:#c678dd>type </span><span>MonsterLayout </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#e06c75>x</span><span style=color:#c678dd>: </span><span style=color:#98c379>'f32'
</span><span>  </span><span style=color:#e06c75>y</span><span style=color:#c678dd>: </span><span style=color:#98c379>'f32'
</span><span>  </span><span style=color:#e06c75>hp</span><span style=color:#c678dd>: </span><span style=color:#98c379>'u8'
</span><span>}
</span><span>
</span><span style=color:#c678dd>const </span><span style=color:#e06c75>monsters </span><span style=color:#c678dd>= </span><span style=color:#e06c75>ParallelArray</span><span>.</span><span style=color:#61afef>init</span><span>&LTMonsterLayout>()
</span></code></pre><p>This seems like a solid interface, but you’ll soon realize that you can’t do anything with the generic parameter other than define types. Implementing the <code>init</code> function is impossible because we didn’t pass in anything. This gives us an important takeaway of TypeScript type-level metaprogramming: You can generate types from values, but not the other way around. So you have to move as much logic to the value-level as possible, even though it’s called type-level metaprogramming. This is one of TypeScript’s limitations, but in this case it’s easy to get around. We can make the layout a run time parameter and let the type system infer the generic parameter.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>ParallelArray&LTT </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint> {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#e06c75>init</span><span style=color:#c678dd><</span><span style=color:#e06c75>T1 extends </span><span style=color:#61afef>Constraint</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>layout</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>T1)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return </span><span style=color:#e06c75>ParallelArray</span><span style=color:#e5c07b>.</span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1>(4)
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1 </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint>(
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>layout</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>T1,
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>  )</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#5c6370>// not implemented
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span><span>
</span><span>
</span><span style=color:#5c6370>// NOTE: const, not type
</span><span style=color:#c678dd>const </span><span style=color:#e06c75>monsterLayout </span><span style=color:#c678dd>= </span><span>{
</span><span>  x: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  y: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  hp: </span><span style=color:#98c379>'u8'</span><span>,
</span><span>} </span><span style=color:#c678dd>as const
</span><span>
</span><span style=color:#c678dd>const </span><span style=color:#e06c75>monsters </span><span style=color:#c678dd>= </span><span style=color:#e06c75>ParallelArray</span><span>.</span><span style=color:#61afef>init</span><span>(</span><span style=color:#e06c75>monsterLayout</span><span>)
</span></code></pre><p>With the layout as a concrete value, we can finally implement <code>withCapacity</code>:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>ParallelArray&LTT </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint> {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1 </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint>(
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>layout</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>T1,
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>  )</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>keys </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>Object.</span><span style=color:#61afef>keys</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>layout</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>constructors </span><span style=color:#c678dd>= </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>.</span><span style=color:#61afef>map</span><span style=color:#e5c07b>((</span><span style=color:#e06c75>k</span><span style=color:#c678dd>: keyof </span><span style=color:#e5c07b>T1) </span><span style=color:#c678dd>=> </span><span style=color:#e06c75>arrayTypes</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>layout</span><span style=color:#e5c07b>[</span><span style=color:#e06c75>k</span><span style=color:#e5c07b>]])
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>return new </span><span style=color:#e5c07b>ParallelArray&LTT1>(
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>,
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>keys</span><span style=color:#e5c07b>,
</span><span style=color:#e5c07b>      </span><span style=color:#61afef>allocateArrays</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>constructors</span><span style=color:#e5c07b>, </span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>),
</span><span style=color:#e5c07b>      0,
</span><span style=color:#e5c07b>      </span><span style=color:#e06c75>capacity</span><span style=color:#e5c07b>,
</span><span style=color:#e5c07b>    )
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>}
</span></code></pre><p>The implementation is smilar to before. The only difference is that we have to populate the read-only properties <code>keys</code> and <code>constructors</code> from the layout type. You can see that some duplicate code started to emerge:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>ParallelArray&LTT </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint> {
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>private readonly </span><span style=color:#e06c75>keys</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>(</span><span style=color:#c678dd>keyof </span><span style=color:#e5c07b>T)[]
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>  </span><span style=color:#c678dd>static </span><span style=color:#61afef>withCapacity</span><span style=color:#e5c07b>&LTT1 </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint>(
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>layout</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>T1,
</span><span style=color:#e5c07b>    </span><span style=color:#e06c75>capacity</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number,
</span><span style=color:#e5c07b>  )</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>ParallelArray&LTT1> {
</span><span style=color:#e5c07b>    </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>key </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>Object.</span><span style=color:#61afef>keys</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>layout</span><span style=color:#e5c07b>)
</span><span style=color:#e5c07b>    </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>  }
</span><span style=color:#e5c07b>  </span><span style=color:#5c6370>// -- snip --
</span><span style=color:#e5c07b>}
</span></code></pre><p>We have to both define the type of <code>keys</code> as <code>keyof T</code> type and initialize the value with <code>Object.keys(layout)</code> where <code>layout</code> is of type <code>T</code>. Similar story with <code>constructors</code> and it’s even worse. This happens a lot with TypeScript, and the only way is to keep the type-level logic as minimal as possible and let type inference do its thing.<h2 id=type-transformation>Type transformation</h2><p>Finally, we need to generalize the <code>Monster</code> and <code>Monsters</code> types. The first one is a record with the same keys as the layout and number values, so implementing it is straightforward.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Item&LTT </span><span style=color:#c678dd>extends </span><span>Constraint> </span><span style=color:#c678dd>= </span><span>Record<</span><span style=color:#c678dd>keyof </span><span>T, number>
</span><span>
</span><span style=color:#c678dd>type </span><span>Monster </span><span style=color:#c678dd>= </span><span>Item<</span><span style=color:#c678dd>typeof </span><span>monsterLayout>
</span></code></pre><p>With the <code>Item&LTT></code> generic type, we can implement the <code>get</code>, <code>set</code>, <code>push</code>, <code>pop</code> methods. I’ll only show the method signature; the implementation is the same as above.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>class </span><span style=color:#e5c07b>ParallelArray&LTT </span><span style=color:#c678dd>extends </span><span style=color:#e5c07b>Constraint> {
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>get</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>idx</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Item&LTT>
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>set</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>idx</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>number, </span><span style=color:#e06c75>item</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Item&LTT>)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>void
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>push</span><span style=color:#e5c07b>(</span><span style=color:#e06c75>item</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Item&LTT>)</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>void
</span><span style=color:#e5c07b>  </span><span style=color:#61afef>pop</span><span style=color:#e5c07b>()</span><span style=color:#c678dd>: </span><span style=color:#e5c07b>Item&LTT> </span><span style=color:#c678dd>| </span><span style=color:#e5c07b>undefined
</span><span style=color:#e5c07b>}
</span></code></pre><p>For the <code>Monsters</code> type, it’s also a record, but the values depend on the keys based on the <code>arrayTypes</code> object, so we need to create our own mapped type.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>View&LTT </span><span style=color:#c678dd>extends </span><span>Constraint> </span><span style=color:#c678dd>= </span><span>{
</span><span>  [K </span><span style=color:#c678dd>in keyof </span><span>T]</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[T[K]]>
</span><span>}
</span></code></pre><p>This is a bit convoluted, so let’s break down a concrete example: the monster layout that we’ve been working with.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>const </span><span style=color:#e06c75>monsterLayout </span><span style=color:#c678dd>= </span><span>{
</span><span>  x: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  y: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  hp: </span><span style=color:#98c379>'u8'</span><span>,
</span><span>} </span><span style=color:#c678dd>as const
</span><span>
</span><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>View<</span><span style=color:#c678dd>typeof </span><span>monsterLayout>
</span></code></pre><p>In this case, <code>T</code> is <code>typeof monsterLayout</code>, which is the type that only accepts the value of <code>monsterLayout</code>. You can think of it as the same thing but operates on type-level. Therefore, <code>keyof T</code> is the union containing all keys of <code>monsterLayout</code>, in other words:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#98c379>'x' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'y' </span><span style=color:#c678dd>| </span><span style=color:#98c379>'hp'
</span></code></pre><p>The syntax of mapped type <code>{[K in keyof T] ...}</code> means that we iterate over all possible values of <code>keyof T</code>, and construct a corresponding value for each value of <code>K</code>. The <code>Monsters</code> type will be expanded as follows:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#98c379>'x'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[(</span><span style=color:#c678dd>typeof </span><span>monsterLayout)[</span><span style=color:#98c379>'x'</span><span>]]>,
</span><span>  </span><span style=color:#98c379>'y'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[(</span><span style=color:#c678dd>typeof </span><span>monsterLayout)[</span><span style=color:#98c379>'y'</span><span>]]>,
</span><span>  </span><span style=color:#98c379>'hp'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[(</span><span style=color:#c678dd>typeof </span><span>monsterLayout)[</span><span style=color:#98c379>'hp'</span><span>]]>,
</span><span>} 
</span></code></pre><p>We can slowly deconstruct this type, starting with this syntax <code>(typeof obj)[key]</code>. This is equivalent to <code>typeof obj[key]</code>, so we can look up the <code>monsterLayout</code> and <code>arrayTypes</code> objects.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#98c379>'x'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[</span><span style=color:#c678dd>typeof </span><span style=color:#98c379>'f32'</span><span>]>,
</span><span>  </span><span style=color:#98c379>'y'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[</span><span style=color:#c678dd>typeof </span><span style=color:#98c379>'f32'</span><span>]>,
</span><span>  </span><span style=color:#98c379>'hp'</span><span style=color:#c678dd>: </span><span>InstanceType<(</span><span style=color:#c678dd>typeof </span><span>arrayTypes)[</span><span style=color:#c678dd>typeof </span><span style=color:#98c379>'u8'</span><span>]>,
</span><span>} 
</span></code></pre><p>But <code>u8</code> and <code>f32</code> are literal types, so we can drop the <code>typeof</code>, giving us<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#98c379>'x'</span><span style=color:#c678dd>: </span><span>InstanceType<</span><span style=color:#c678dd>typeof </span><span>Float32Array>,
</span><span>  </span><span style=color:#98c379>'y'</span><span style=color:#c678dd>: </span><span>InstanceType<</span><span style=color:#c678dd>typeof </span><span>Float32Array>,
</span><span>  </span><span style=color:#98c379>'hp'</span><span style=color:#c678dd>: </span><span>InstanceType<</span><span style=color:#c678dd>typeof </span><span>Uint8Array>,
</span><span>} 
</span></code></pre><p>We already established that taking the type of a concrete class value gives its constructor, and the <code>InstanceType</code> utility type gives us back the class type.<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>type </span><span>Monsters </span><span style=color:#c678dd>= </span><span>{
</span><span>  </span><span style=color:#98c379>'x'</span><span style=color:#c678dd>: </span><span>Float32Array,
</span><span>  </span><span style=color:#98c379>'y'</span><span style=color:#c678dd>: </span><span>Float32Array,
</span><span>  </span><span style=color:#98c379>'hp'</span><span style=color:#c678dd>: </span><span>Uint8Array,
</span><span>} 
</span></code></pre><p>This is exactly the <code>Monsters</code> type we manually defined before, and hopefully you can see how it will work with any objects that satisfies <code>Constraint</code>. From the <code>View&LTT></code> type, you can annotate and implement the <code>view</code> method. So this concludes the implementation of the <code>ParallelArray</code> class.<h1 id=extra-features>Extra features</h1><p>Here are some extra features that I left out of this article. Mainly because they are not specific to the idea of SoA and can be trivially implemented from the described methods above.<ul><li><strong>Resizing:</strong> Modify the array so that its length becomes a specified length. If the new length is smaller, the array is truncated; otherwise, the array is padded with zero.<li><strong>Power of 2 size:</strong> The internal array buffer is aligned to have power-of-two capacity. It may or may not affect performance, and it’s just a matter of taste.<li><strong>Lazy view updating:</strong> The view is only changed after some operations: <code>push</code>, <code>pop</code>, <code>resize</code>, etc. So these operations mark the view as dirty, and they are corrected when requested. Otherwise, a cached view is used.<li><strong>Out parameter for get and pop:</strong> This is only for marginally improving the performance of single element indexing, especially when the out object is reused.<li><strong>Copying:</strong> Create a separate copy of the array with the same data. This is extremely fast thanks to typed arrays.</ul><p>There are also some other useful features that I haven’t implemented:<ul><li><strong>Slicing:</strong> Creating subarray references is very useful and makes the implementation of several algorithms extremely clean. However, implementing this requires creating a fixed-size variant of the array, which requires careful consideration.<li><strong>Sorting:</strong> Naturally, this data structure is not compatible with the native <code>Array.prototype.sort</code>, but this can be implemented using index sorting and in-place permutation. Also, for integer values, we can use radix sort, which may or may not be faster than the native JavaScript sorting algorithm. This is very interesting, and I’ll make sure to implement and perform benchmarks in the future.<li><strong>Arbitrary insert/remove:</strong> I don’t use this often, or at all, actually, so I don’t bother implementing it. If you need to use this feature, consider alternative data representation (even linked lists).</ul><h1 id=microbenchmarks>Microbenchmarks</h1><p>While the reduced memory usage benefit is crystal clear, I can’t make any claim about performance without proper measurement. I planned on conducting more elaborate tests later, but for now microbenchmarks are all that we have. For this, we’ll use the following layout:<pre class=language-ts data-lang=ts style=color:#dcdfe4;background-color:#282c34><code class=language-ts data-lang=ts><span style=color:#c678dd>const </span><span style=color:#e06c75>particleLayout </span><span style=color:#c678dd>= </span><span>{
</span><span>  id: </span><span style=color:#98c379>'u32'</span><span>,
</span><span>  x: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  y: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  vx: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>  vy: </span><span style=color:#98c379>'f32'</span><span>,
</span><span>} </span><span style=color:#c678dd>as const
</span><span>
</span><span style=color:#c678dd>type </span><span>Particle </span><span style=color:#c678dd>= </span><span>Item<</span><span style=color:#c678dd>typeof </span><span>particleLayout>
</span><span>
</span><span style=color:#c678dd>type </span><span>ParticlesSoA </span><span style=color:#c678dd>= </span><span>ParallelArray<</span><span style=color:#c678dd>typeof </span><span>particleLayout>
</span><span style=color:#c678dd>type </span><span>ParticlesAoS </span><span style=color:#c678dd>= </span><span>Particle[]
</span></code></pre><p>We’ll test the following operations:<ol><li>Fill an array with <code>push</code><li>Fill an array by resizing and assigning in a loop<li>Access elements with <code>get</code> (wide)<li>Access elements with <code>view</code> (narrow)<li>Copying</ol><p>I tested with 1 million random items. For the read tests, I tested both random access and sequential access patterns. For more information about the test procedure, take a look at the <a href=//github.com/ziap/parallel-array/blob/master/src/bench.ts>benchmark file</a>.<table><thead><tr><th>Benchmark<th>Array of Objects (AoS)<th>Parallel Array (SoA)<th>Difference<tbody><tr><td>push<td>92.3 ms<td><strong>85.4 ms</strong><td>1.08x<tr><td>push (withCapacity)<td>-<td><strong>79.9 ms</strong><td>1.16x<tr><td>resize + assign<td>41.8 ms<td><strong>24.9 ms</strong><td>1.68x<tr><td>wide read (sequential)<td><strong>6.4 ms</strong><td>50.4 ms<td><strong>7.87x</strong><tr><td>wide read (random)<td><strong>167.3 ms</strong><td>180.5 ms<td>1.07x<tr><td>narrow read (sequential)<td>5.5 ms<td><strong>0.7 ms</strong><td><strong>7.85x</strong><tr><td>narrow read (random)<td>148.1 ms<td><strong>9.9 ms</strong><td><strong>14.96x</strong><tr><td>copy<td>34.1 ms<td><strong>7.6 ms</strong><td><strong>4.49x</strong></table><p>There’s a lot to unpack here, so I won’t. Make of that what you will with the benchmark results above. I want to perform more thorough benchmarks to see the actual difference in real-world usage. My two cents from just this is that the SoA <code>ParallelArray</code> is an okay implementation with acceptable overhead such that we get improvements over the standard, natively implemented JavaScript array in places where it is expected to perform better.<h1 id=conclusion>Conclusion</h1><p>So that’s how I implemented a convenient and type-safe SoA on top of typed arrays in TypeScript. As I said at the beginning, I started this endeavor to learn more about type-level metaprogramming in TypeScript. Is this useful for web development? Most likely not; the typical front-end workload does not require processing massive amounts of data in a tight time window. And if you need better performance, then <a href=/blog/wasm>WebAssembly</a> is probably a better choice.<p>I still think that this problem is interesting because it involves metaprogramming for constructing types on the fly, and there’s the challenge of balancing between convenience and abstraction overhead. In the next articles, I’ll write about using this data representation to optimize two problems: a typical game/simulation scenario and a state-space search algorithm. The full implementation is available <a href=//github.com/ziap/parallel-array/>here</a>.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Ishan (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>